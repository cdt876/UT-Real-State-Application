<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="SAMPLE_PKG" directorySegmentName="seg_0" id="B0D3F3F9-080D-2916-06A4-1514669FB5AC">
<sourceDDLFile>schema_test.sql</sourceDDLFile>
<createdBy>carlostrejo</createdBy>
<createdTime>2015-07-06 20:04:57 UTC</createdTime>
<ownerDesignName>nimblepm_datamodel</ownerDesignName>
<source>CREATE OR REPLACE PACKAGE  SAMPLE_PKG is&lt;br/&gt;    --&lt;br/&gt;    -- Error Handling function&lt;br/&gt;    --&lt;br/&gt;    function demo_error_handling (&lt;br/&gt;        p_error in apex_error.t_error )&lt;br/&gt;        return apex_error.t_error_result;&lt;br/&gt;    &lt;br/&gt;    --&lt;br/&gt;    -- Tag Cleaner function&lt;br/&gt;    --&lt;br/&gt;    function demo_tags_cleaner (&lt;br/&gt;        p_tags  in varchar2,&lt;br/&gt;        p_case  in varchar2 default &apos;U&apos;) &lt;br/&gt;        return varchar2;&lt;br/&gt;    &lt;br/&gt;    --&lt;br/&gt;    -- Tag Synchronisation Procedure&lt;br/&gt;    --&lt;br/&gt;    procedure demo_tag_sync (&lt;br/&gt;        p_new_tags          in varchar2,&lt;br/&gt;        p_old_tags          in varchar2,&lt;br/&gt;        p_content_type      in varchar2,&lt;br/&gt;        p_content_id        in number );&lt;br/&gt;end sample_pkg;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="SAMPLE_PKG" id="B0D3F3F9-080D-2916-06A4-1514669FB5AC">
<createdBy>carlostrejo</createdBy>
<createdTime>2015-07-06 20:05:16 UTC</createdTime>
<ownerDesignName>nimblepm_datamodel</ownerDesignName>
<source>CREATE OR REPLACE PACKAGE BODY  SAMPLE_PKG as&lt;br/&gt;    --&lt;br/&gt;    -- Error Handling function&lt;br/&gt;    --&lt;br/&gt;    function demo_error_handling (&lt;br/&gt;        p_error in apex_error.t_error )&lt;br/&gt;        return apex_error.t_error_result&lt;br/&gt;    is&lt;br/&gt;        l_result          apex_error.t_error_result;&lt;br/&gt;        l_reference_id    number;&lt;br/&gt;        l_constraint_name varchar2(255);&lt;br/&gt;    begin&lt;br/&gt;        l_result := apex_error.init_error_result (&lt;br/&gt;                        p_error =&gt; p_error );&lt;br/&gt;        -- If it&apos;s an internal error raised by APEX, like an invalid statement or&lt;br/&gt;        -- code which can&apos;t be executed, the error text might contain security sensitive&lt;br/&gt;        -- information. To avoid this security problem we can rewrite the error to&lt;br/&gt;        -- a generic error message and log the original error message for further&lt;br/&gt;        -- investigation by the help desk.&lt;br/&gt;        if p_error.is_internal_error then&lt;br/&gt;            -- mask all errors that are not common runtime errors (Access Denied&lt;br/&gt;            -- errors raised by application / page authorization and all errors&lt;br/&gt;            -- regarding session and session state)&lt;br/&gt;            if not p_error.is_common_runtime_error then&lt;br/&gt;                -- log error for example with an autonomous transaction and return&lt;br/&gt;                -- l_reference_id as reference#&lt;br/&gt;                -- l_reference_id := log_error (&lt;br/&gt;                --                       p_error =&gt; p_error );&lt;br/&gt;                --&lt;br/&gt;    &lt;br/&gt;                -- Change the message to the generic error message which doesn&apos;t expose&lt;br/&gt;                -- any sensitive information.&lt;br/&gt;                l_result.message         := &apos;An unexpected internal application error has occurred. &apos;||&lt;br/&gt;                                            &apos;Please get in contact with your system administrator and provide &apos;||&lt;br/&gt;                                            &apos;reference# &apos;||to_char(l_reference_id, &apos;999G999G999G990&apos;)||&lt;br/&gt;                                            &apos; for further investigation.&apos;;&lt;br/&gt;                l_result.additional_info := null;&lt;br/&gt;            end if;&lt;br/&gt;        else&lt;br/&gt;            -- Always show the error as inline error&lt;br/&gt;            -- Note: If you have created manual tabular forms (using the package&lt;br/&gt;            --       apex_item/htmldb_item in the SQL statement) you should still&lt;br/&gt;            --       use &quot;On error page&quot; on that pages to avoid loosing entered data&lt;br/&gt;            l_result.display_location := case&lt;br/&gt;                                           when l_result.display_location = apex_error.c_on_error_page then apex_error.c_inline_in_notification&lt;br/&gt;                                           else l_result.display_location&lt;br/&gt;                                         end;&lt;br/&gt;    &lt;br/&gt;            -- If it&apos;s a constraint violation like&lt;br/&gt;            --&lt;br/&gt;            --   -) ORA-00001: unique constraint violated&lt;br/&gt;            --   -) ORA-02091: transaction rolled back (-&gt; can hide a deferred constraint)&lt;br/&gt;            --   -) ORA-02290: check constraint violated&lt;br/&gt;            --   -) ORA-02291: integrity constraint violated - parent key not found&lt;br/&gt;            --   -) ORA-02292: integrity constraint violated - child record found&lt;br/&gt;            --&lt;br/&gt;            -- we try to get a friendly error message from our constraint lookup configuration.&lt;br/&gt;            -- If we don&apos;t find the constraint in our lookup table we fallback to&lt;br/&gt;            -- the original ORA error message.&lt;br/&gt;            if p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then&lt;br/&gt;                l_constraint_name := apex_error.extract_constraint_name (&lt;br/&gt;                                         p_error =&gt; p_error );&lt;br/&gt;                begin&lt;br/&gt;                    select message&lt;br/&gt;                      into l_result.message&lt;br/&gt;                      from demo_constraint_lookup&lt;br/&gt;                     where constraint_name = l_constraint_name;&lt;br/&gt;                exception when no_data_found then null; -- not every constraint has to be in our lookup table&lt;br/&gt;                end;&lt;br/&gt;            end if;&lt;br/&gt;            -- If an ORA error has been raised, for example a raise_application_error(-20xxx, &apos;...&apos;)&lt;br/&gt;                -- in a table trigger or in a PL/SQL package called by a process and we&lt;br/&gt;            -- haven&apos;t found the error in our lookup table, then we just want to see&lt;br/&gt;            -- the actual error text and not the full error stack with all the ORA error numbers.&lt;br/&gt;            if p_error.ora_sqlcode is not null and l_result.message = p_error.message then&lt;br/&gt;                l_result.message := apex_error.get_first_ora_error_text (&lt;br/&gt;                                        p_error =&gt; p_error );&lt;br/&gt;            end if;&lt;br/&gt;            -- If no associated page item/tabular form column has been set, we can use&lt;br/&gt;            -- apex_error.auto_set_associated_item to automatically guess the affected&lt;br/&gt;            -- error field by examine the ORA error for constraint names or column names.&lt;br/&gt;            if l_result.page_item_name is null and l_result.column_alias is null then&lt;br/&gt;                apex_error.auto_set_associated_item (&lt;br/&gt;                    p_error        =&gt; p_error,&lt;br/&gt;                    p_error_result =&gt; l_result );&lt;br/&gt;            end if;&lt;br/&gt;        end if;&lt;br/&gt;        return l_result;&lt;br/&gt;    end demo_error_handling;&lt;br/&gt;        &lt;br/&gt;    &lt;br/&gt;    ---&lt;br/&gt;    --- Tag Cleaner function&lt;br/&gt;    ---&lt;br/&gt;    function demo_tags_cleaner (&lt;br/&gt;        p_tags  in varchar2,&lt;br/&gt;        p_case  in varchar2 default &apos;U&apos; ) return varchar2&lt;br/&gt;    is&lt;br/&gt;        type tags is table of varchar2(255) index by varchar2(255);&lt;br/&gt;        l_tags_a        tags;&lt;br/&gt;        l_tag           varchar2(255);&lt;br/&gt;        l_tags          apex_application_global.vc_arr2;&lt;br/&gt;        l_tags_string   varchar2(32767);&lt;br/&gt;        i               integer;&lt;br/&gt;    begin&lt;br/&gt;        l_tags := apex_util.string_to_table(p_tags,&apos;,&apos;);&lt;br/&gt;        for i in 1..l_tags.count loop&lt;br/&gt;            --remove all whitespace, including tabs, spaces, line feeds and carraige returns with a single space&lt;br/&gt;            l_tag := substr(trim(regexp_replace(l_tags(i),&apos;[[:space:]]{1,}&apos;,&apos; &apos;)),1,255);&lt;br/&gt;  &lt;br/&gt;            if l_tag is not null and l_tag != &apos; &apos; then&lt;br/&gt;                if p_case = &apos;U&apos; then&lt;br/&gt;                    l_tag := upper(l_tag);&lt;br/&gt;                elsif p_case = &apos;L&apos; then&lt;br/&gt;                    l_tag := lower(l_tag);&lt;br/&gt;                end if;&lt;br/&gt;                --add it to the associative array, if it is a duplicate, it will just be replaced&lt;br/&gt;                l_tags_a(l_tag) := l_tag;&lt;br/&gt;            end if;&lt;br/&gt;        end loop;&lt;br/&gt;        l_tag := null;&lt;br/&gt;        l_tag := l_tags_a.first;&lt;br/&gt;        while l_tag is not null loop&lt;br/&gt;            l_tags_string := l_tags_string||l_tag;&lt;br/&gt;            if l_tag != l_tags_a.last then&lt;br/&gt;                l_tags_string := l_tags_string||&apos;, &apos;;&lt;br/&gt;            end if;&lt;br/&gt;            l_tag := l_tags_a.next(l_tag);&lt;br/&gt;        end loop;&lt;br/&gt;        return substr(l_tags_string,1,4000);&lt;br/&gt;    end demo_tags_cleaner;&lt;br/&gt;    ---&lt;br/&gt;    --- Tag Synchronisation Procedure&lt;br/&gt;    ---&lt;br/&gt;    procedure demo_tag_sync (&lt;br/&gt;        p_new_tags          in varchar2,&lt;br/&gt;        p_old_tags          in varchar2,&lt;br/&gt;        p_content_type      in varchar2,&lt;br/&gt;        p_content_id        in number )&lt;br/&gt;    as&lt;br/&gt;        type tags is table of varchar2(255) index by varchar2(255);&lt;br/&gt;        l_new_tags_a    tags;&lt;br/&gt;        l_old_tags_a    tags;&lt;br/&gt;        l_new_tags      apex_application_global.vc_arr2;&lt;br/&gt;        l_old_tags      apex_application_global.vc_arr2;&lt;br/&gt;        l_merge_tags    apex_application_global.vc_arr2;&lt;br/&gt;        l_dummy_tag     varchar2(255);&lt;br/&gt;        i               integer;&lt;br/&gt;    begin&lt;br/&gt;        l_old_tags := apex_util.string_to_table(p_old_tags,&apos;, &apos;);&lt;br/&gt;        l_new_tags := apex_util.string_to_table(p_new_tags,&apos;, &apos;);&lt;br/&gt;        if l_old_tags.count &gt; 0 then --do inserts and deletes&lt;br/&gt;            --build the associative arrays&lt;br/&gt;            for i in 1..l_old_tags.count loop&lt;br/&gt;                l_old_tags_a(l_old_tags(i)) := l_old_tags(i);&lt;br/&gt;            end loop;&lt;br/&gt;            for i in 1..l_new_tags.count loop&lt;br/&gt;                l_new_tags_a(l_new_tags(i)) := l_new_tags(i);&lt;br/&gt;            end loop;&lt;br/&gt;            --do the inserts&lt;br/&gt;            for i in 1..l_new_tags.count loop&lt;br/&gt;                begin&lt;br/&gt;                    l_dummy_tag := l_old_tags_a(l_new_tags(i));&lt;br/&gt;                exception when no_data_found then&lt;br/&gt;                    insert into demo_tags (tag, content_id, content_type )&lt;br/&gt;                        values (l_new_tags(i), p_content_id, p_content_type );&lt;br/&gt;                    l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);&lt;br/&gt;                end;&lt;br/&gt;            end loop;&lt;br/&gt;            --do the deletes&lt;br/&gt;            for i in 1..l_old_tags.count loop&lt;br/&gt;                begin&lt;br/&gt;                    l_dummy_tag := l_new_tags_a(l_old_tags(i));&lt;br/&gt;                exception when no_data_found then&lt;br/&gt;                    delete from demo_tags where content_id = p_content_id and tag = l_old_tags(i);&lt;br/&gt;                    l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);&lt;br/&gt;                end;&lt;br/&gt;            end loop;&lt;br/&gt;        else --just do inserts&lt;br/&gt;            for i in 1..l_new_tags.count loop&lt;br/&gt;                insert into demo_tags (tag, content_id, content_type )&lt;br/&gt;                    values (l_new_tags(i), p_content_id, p_content_type );&lt;br/&gt;                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);&lt;br/&gt;            end loop;&lt;br/&gt;        end if;&lt;br/&gt;        for i in 1..l_merge_tags.count loop&lt;br/&gt;            merge into demo_tags_type_sum s&lt;br/&gt;            using (select count(*) tag_count&lt;br/&gt;                     from demo_tags&lt;br/&gt;                    where tag = l_merge_tags(i) and content_type = p_content_type ) t&lt;br/&gt;               on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )&lt;br/&gt;             when not matched then insert (tag, content_type, tag_count)&lt;br/&gt;                                   values (l_merge_tags(i), p_content_type, t.tag_count)&lt;br/&gt;             when matched then update set s.tag_count = t.tag_count;&lt;br/&gt;            merge into demo_tags_sum s&lt;br/&gt;            using (select sum(tag_count) tag_count&lt;br/&gt;                     from demo_tags_type_sum&lt;br/&gt;                    where tag = l_merge_tags(i) ) t&lt;br/&gt;               on (s.tag = l_merge_tags(i) )&lt;br/&gt;             when not matched then insert (tag, tag_count)&lt;br/&gt;                                   values (l_merge_tags(i), t.tag_count)&lt;br/&gt;             when matched then update set s.tag_count = t.tag_count;&lt;br/&gt;        end loop;&lt;br/&gt;    end demo_tag_sync;&lt;br/&gt;end sample_pkg;</source>
</body>
</PackageOracle>